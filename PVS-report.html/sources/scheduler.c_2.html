<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>scheduler.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java:</a>
<a name="ln3">// https://pvs-studio.com</a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;scheduler.h&quot;</a>
<a name="ln6">#include &quot;doubleLinkedList.h&quot;</a>
<a name="ln7">#include &quot;memoryManager.h&quot;</a>
<a name="ln8">#include &quot;memoryMap.h&quot;</a>
<a name="ln9">#include &quot;process.h&quot;</a>
<a name="ln10">#include &quot;time.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;video.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">extern void timer_tick();</a>
<a name="ln15"> </a>
<a name="ln16">static void adopt_children(int64_t pid);</a>
<a name="ln17">static int remove_process(int64_t pid);</a>
<a name="ln18">static process_t *get_process(int64_t pid);</a>
<a name="ln19">static process_t *get_current_process(void);</a>
<a name="ln20">static void enqueue_ready(process_t *proc);</a>
<a name="ln21">static process_t *dequeue_ready(void);</a>
<a name="ln22">static void remove_from_ready_queue(process_t *proc);</a>
<a name="ln23">static uint8_t quantum_for_priority(uint8_t priority);</a>
<a name="ln24">static void free_ready_queue(void);</a>
<a name="ln25"> </a>
<a name="ln26">static schedulerADT scheduler = NULL;</a>
<a name="ln27"> </a>
<a name="ln28">static void init(int argc, char **argv) {</a>
<a name="ln29">  char *shell_argv[] = {NULL};</a>
<a name="ln30"> </a>
<a name="ln31">  if (SHELL_ADDRESS == 0 || SHELL_ADDRESS == (void *)-1) {</a>
<a name="ln32">    while (1)</a>
<a name="ln33">      _hlt();</a>
<a name="ln34">  }</a>
<a name="ln35"> </a>
<a name="ln36">  int shell_pid =</a>
<a name="ln37">      add_process((entry_point_t)SHELL_ADDRESS, shell_argv, &quot;shell&quot;, NULL);</a>
<a name="ln38"> </a>
<a name="ln39">  if (shell_pid &lt; 0) {</a>
<a name="ln40">    while (1)</a>
<a name="ln41">      _hlt();</a>
<a name="ln42">  }</a>
<a name="ln43"> </a>
<a name="ln44">  while (1) {</a>
<a name="ln45">    _hlt();</a>
<a name="ln46">  }</a>
<a name="ln47">}</a>
<a name="ln48"> </a>
<a name="ln49">static int add_init() {</a>
<a name="ln50">  if (!scheduler || scheduler-&gt;process_count != 0) {</a>
<a name="ln51">    return -1;</a>
<a name="ln52">  }</a>
<a name="ln53"> </a>
<a name="ln54">  // VER!!: ACA EL NULL QUE PASE COMO FD probablemente cambie</a>
<a name="ln55">  process_t *pcb_init =</a>
<a name="ln56">      my_create_process(INIT_PID, (entry_point_t)init, NULL, &quot;init&quot;, NULL);</a>
<a name="ln57"> </a>
<a name="ln58">  if (pcb_init == NULL) {</a>
<a name="ln59">    return -1;</a>
<a name="ln60">  }</a>
<a name="ln61"> </a>
<a name="ln62">  pcb_init-&gt;priority = MIN_PRIORITY;</a>
<a name="ln63">  pcb_init-&gt;state = PROC_READY;</a>
<a name="ln64">  pcb_init-&gt;remaining_quantum = quantum_for_priority(pcb_init-&gt;priority);</a>
<a name="ln65">  pcb_init-&gt;ticks = 0;</a>
<a name="ln66"> </a>
<a name="ln67">  scheduler-&gt;processes[INIT_PID] = pcb_init;</a>
<a name="ln68">  scheduler-&gt;process_count++;</a>
<a name="ln69"> </a>
<a name="ln70">  return 0;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">void init_scheduler(void) {</a>
<a name="ln74">  if (scheduler != NULL) {</a>
<a name="ln75">    return;</a>
<a name="ln76">  }</a>
<a name="ln77"> </a>
<a name="ln78">  scheduler = (schedulerADT)SCHEDULER_ADDRESS;</a>
<a name="ln79"> </a>
<a name="ln80">  for (int i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln81">    scheduler-&gt;processes[i] = NULL;</a>
<a name="ln82">  }</a>
<a name="ln83"> </a>
<a name="ln84">  scheduler-&gt;current_pid = NO_PID;</a>
<a name="ln85">  scheduler-&gt;process_count = 0;</a>
<a name="ln86">  scheduler-&gt;ready_queue = create_list();</a>
<a name="ln87">  if (scheduler-&gt;ready_queue == NULL) {</a>
<a name="ln88">    scheduler = NULL;</a>
<a name="ln89">    return;</a>
<a name="ln90">  }</a>
<a name="ln91">  scheduler-&gt;total_cpu_ticks = 0;</a>
<a name="ln92">  scheduler-&gt;force_reschedule = 0;</a>
<a name="ln93"> </a>
<a name="ln94">  if (add_init() != 0) {</a>
<a name="ln95">    free_ready_queue();</a>
<a name="ln96">    scheduler = NULL;</a>
<a name="ln97">  }</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">void *schedule(void *prev_rsp) {</a>
<a name="ln101">  if (scheduler == NULL || scheduler-&gt;process_count == 0) {</a>
<a name="ln102">    scheduler-&gt;force_reschedule = 0;</a>
<a name="ln103">    return prev_rsp;</a>
<a name="ln104">  }</a>
<a name="ln105"> </a>
<a name="ln106">  process_t *current_process = get_current_process();</a>
<a name="ln107"> </a>
<a name="ln108">  if (current_process != NULL) {</a>
<a name="ln109">    current_process-&gt;stack_pointer = prev_rsp;</a>
<a name="ln110">    current_process-&gt;ticks++;</a>
<a name="ln111">    scheduler-&gt;total_cpu_ticks++;</a>
<a name="ln112"> </a>
<a name="ln113">    if (current_process-&gt;state == PROC_RUNNING &amp;&amp;</a>
<a name="ln114">        current_process-&gt;remaining_quantum &gt; 0) {</a>
<a name="ln115">      current_process-&gt;remaining_quantum--;</a>
<a name="ln116">    }</a>
<a name="ln117"> </a>
<a name="ln118">    if (current_process-&gt;state == PROC_RUNNING &amp;&amp;</a>
<a name="ln119">        current_process-&gt;remaining_quantum &gt; 0 &amp;&amp;</a>
<a name="ln120">        !scheduler-&gt;force_reschedule) {</a>
<a name="ln121">      return prev_rsp;</a>
<a name="ln122">    }</a>
<a name="ln123"> </a>
<a name="ln124">    if (current_process-&gt;state == PROC_RUNNING) {</a>
<a name="ln125">      current_process-&gt;state = PROC_READY;</a>
<a name="ln126">    }</a>
<a name="ln127"> </a>
<a name="ln128">    if (current_process-&gt;state == PROC_READY &amp;&amp;</a>
<a name="ln129">        current_process-&gt;pid != INIT_PID) {</a>
<a name="ln130">      enqueue_ready(current_process);</a>
<a name="ln131">      if (!current_process</a>
<a name="ln132">               -&gt;in_ready_queue) {</a>
<a name="ln133">        current_process-&gt;state = PROC_RUNNING;</a>
<a name="ln134">        current_process-&gt;remaining_quantum =</a>
<a name="ln135">            quantum_for_priority(current_process-&gt;priority);</a>
<a name="ln136">        scheduler-&gt;force_reschedule = 0;</a>
<a name="ln137">        return prev_rsp;</a>
<a name="ln138">      }</a>
<a name="ln139">    }</a>
<a name="ln140">  }</a>
<a name="ln141"> </a>
<a name="ln142">  process_t *next_process = dequeue_ready();</a>
<a name="ln143"> </a>
<a name="ln144">  if (next_process == NULL) {</a>
<a name="ln145">    next_process = scheduler-&gt;processes[INIT_PID];</a>
<a name="ln146">  }</a>
<a name="ln147"> </a>
<a name="ln148">  scheduler-&gt;current_pid = next_process-&gt;pid;</a>
<a name="ln149">  next_process-&gt;state = PROC_RUNNING;</a>
<a name="ln150">  next_process-&gt;remaining_quantum =</a>
<a name="ln151">      quantum_for_priority(next_process-&gt;priority);</a>
<a name="ln152">  scheduler-&gt;force_reschedule = 0;</a>
<a name="ln153">  return next_process-&gt;stack_pointer;</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">int64_t add_process(entry_point_t main, char **argv, char *name,</a>
<a name="ln157">                    int *file_descriptors) {</a>
<a name="ln158">  if (scheduler == NULL || scheduler-&gt;process_count &gt;= MAX_PROCESSES) {</a>
<a name="ln159">    return -1;</a>
<a name="ln160">  }</a>
<a name="ln161"> </a>
<a name="ln162">  int pid = NO_PID;</a>
<a name="ln163">  for (int i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln164">    if (scheduler-&gt;processes[i] == NULL) {</a>
<a name="ln165">      pid = i;</a>
<a name="ln166">      break;</a>
<a name="ln167">    }</a>
<a name="ln168">  }</a>
<a name="ln169"> </a>
<a name="ln170">  if (pid == NO_PID) {</a>
<a name="ln171">    return -1;</a>
<a name="ln172">  }</a>
<a name="ln173"> </a>
<a name="ln174">  process_t *new_process =</a>
<a name="ln175">      my_create_process(pid, main, argv, name, file_descriptors);</a>
<a name="ln176"> </a>
<a name="ln177">  if (new_process == NULL) {</a>
<a name="ln178">    return NO_PID;</a>
<a name="ln179">  }</a>
<a name="ln180"> </a>
<a name="ln181">  new_process-&gt;priority = DEFAULT_PRIORITY;</a>
<a name="ln182">  new_process-&gt;remaining_quantum = quantum_for_priority(new_process-&gt;priority);</a>
<a name="ln183">  new_process-&gt;state = PROC_READY;</a>
<a name="ln184">  new_process-&gt;ticks = 0;</a>
<a name="ln185"> </a>
<a name="ln186">  scheduler-&gt;processes[pid] = new_process;</a>
<a name="ln187">  scheduler-&gt;process_count++;</a>
<a name="ln188"> </a>
<a name="ln189">  enqueue_ready(new_process);</a>
<a name="ln190"> </a>
<a name="ln191">  return pid;</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">static process_t *get_process(int64_t pid) {</a>
<a name="ln195">  if (scheduler == NULL || pid &lt; 0 || pid &gt;= MAX_PROCESSES) {</a>
<a name="ln196">    return NULL;</a>
<a name="ln197">  }</a>
<a name="ln198">  return scheduler-&gt;processes[pid];</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">static process_t *get_current_process() {</a>
<a name="ln202">  if (scheduler == NULL || scheduler-&gt;current_pid == NO_PID) {</a>
<a name="ln203">    return NULL;</a>
<a name="ln204">  }</a>
<a name="ln205">  return get_process(scheduler-&gt;current_pid);</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">void scheduler_destroy() {</a>
<a name="ln209">  if (scheduler == NULL) {</a>
<a name="ln210">    return;</a>
<a name="ln211">  }</a>
<a name="ln212"> </a>
<a name="ln213">  for (uint64_t i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln214">    if (scheduler-&gt;processes[i] != NULL) {</a>
<a name="ln215">      process_destroy(scheduler-&gt;processes[i]);</a>
<a name="ln216">      scheduler-&gt;processes[i] = NULL;</a>
<a name="ln217">    }</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">  free_ready_queue();</a>
<a name="ln221"> </a>
<a name="ln222">  memory_free(scheduler);</a>
<a name="ln223">  scheduler = NULL;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">int64_t get_current_pid() {</a>
<a name="ln227">  if (scheduler == NULL) {</a>
<a name="ln228">    return -1;</a>
<a name="ln229">  }</a>
<a name="ln230">  return scheduler-&gt;current_pid;</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">void yield() {</a>
<a name="ln234">  scheduler-&gt;force_reschedule = 1;</a>
<a name="ln235">  timer_tick();</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">static void adopt_children(int64_t pid) {</a>
<a name="ln239">  if (scheduler == NULL || pid &lt; 0 || pid &gt;= MAX_PROCESSES) {</a>
<a name="ln240">    return;</a>
<a name="ln241">  }</a>
<a name="ln242"> </a>
<a name="ln243">  for (uint64_t i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln244"> </a>
<a name="ln245">    process_t *child = scheduler-&gt;processes[i];</a>
<a name="ln246"> </a>
<a name="ln247">    if (child != NULL &amp;&amp; child-&gt;parent_pid == pid) {</a>
<a name="ln248">      child-&gt;parent_pid = INIT_PID;</a>
<a name="ln249">    }</a>
<a name="ln250">  }</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">static int remove_process(int64_t pid) {</a>
<a name="ln254"> </a>
<a name="ln255">  if (scheduler == NULL || pid &lt; 0 || pid &gt;= MAX_PROCESSES) {</a>
<a name="ln256">    return -1;</a>
<a name="ln257">  }</a>
<a name="ln258"> </a>
<a name="ln259">  process_t *proc = scheduler-&gt;processes[pid];</a>
<a name="ln260"> </a>
<a name="ln261">  if (proc == NULL) {</a>
<a name="ln262">    return -1;</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">  if (proc-&gt;state == PROC_READY || proc-&gt;state == PROC_RUNNING) {</a>
<a name="ln266">    remove_from_ready_queue(proc);</a>
<a name="ln267">  }</a>
<a name="ln268"> </a>
<a name="ln269">  scheduler-&gt;processes[pid] = NULL;</a>
<a name="ln270">  scheduler-&gt;process_count--;</a>
<a name="ln271">  process_destroy(proc);</a>
<a name="ln272"> </a>
<a name="ln273">  if (scheduler-&gt;current_pid == pid) {</a>
<a name="ln274">    scheduler-&gt;current_pid = NO_PID;</a>
<a name="ln275">    yield();</a>
<a name="ln276">  }</a>
<a name="ln277"> </a>
<a name="ln278">  return 0;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">int kill_process(int64_t pid) {</a>
<a name="ln282"> </a>
<a name="ln283">  if (get_process(pid) == NULL) {</a>
<a name="ln284">    return -1;</a>
<a name="ln285">  }</a>
<a name="ln286">  adopt_children(pid);</a>
<a name="ln287"> </a>
<a name="ln288">  process_t *proc = scheduler-&gt;processes[pid];</a>
<a name="ln289">  process_t *parent = scheduler-&gt;processes[proc-&gt;parent_pid];</a>
<a name="ln290"> </a>
<a name="ln291">  proc-&gt;state = PROC_KILLED;</a>
<a name="ln292">  if (proc-&gt;in_ready_queue || proc-&gt;state == PROC_READY ||</a>
<a name="ln293">      proc-&gt;state == PROC_RUNNING) {</a>
<a name="ln294">    remove_from_ready_queue(proc);</a>
<a name="ln295">  }</a>
<a name="ln296"> </a>
<a name="ln297">  if (parent != NULL &amp;&amp; parent-&gt;state == PROC_BLOCKED &amp;&amp;</a>
<a name="ln298">      parent-&gt;waiting_pid == pid) {</a>
<a name="ln299">    unblock_process(parent-&gt;pid);</a>
<a name="ln300">  }</a>
<a name="ln301"> </a>
<a name="ln302">  if (proc-&gt;parent_pid == INIT_PID) {</a>
<a name="ln303">    remove_process(pid);</a>
<a name="ln304">  } else if (parent == NULL || parent-&gt;waiting_pid != pid) {</a>
<a name="ln305">    remove_process(pid);</a>
<a name="ln306">  }</a>
<a name="ln307">  if (pid == scheduler-&gt;current_pid) {</a>
<a name="ln308">    yield();</a>
<a name="ln309">  }</a>
<a name="ln310">  return 0;</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">int kill_current_process() {</a>
<a name="ln314">  int64_t pid = get_current_pid();</a>
<a name="ln315">  if (pid == NO_PID) {</a>
<a name="ln316">    return -1;</a>
<a name="ln317">  }</a>
<a name="ln318">  return kill_process(pid);</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">int block_process(int64_t pid) {</a>
<a name="ln322">  if (get_process(pid) == NULL) {</a>
<a name="ln323">    return -1;</a>
<a name="ln324">  }</a>
<a name="ln325"> </a>
<a name="ln326">  process_t *proc = scheduler-&gt;processes[pid];</a>
<a name="ln327"> </a>
<a name="ln328">  if (proc-&gt;state != PROC_READY &amp;&amp; proc-&gt;state != PROC_RUNNING) {</a>
<a name="ln329">    return -1;</a>
<a name="ln330">  }</a>
<a name="ln331"> </a>
<a name="ln332">  remove_from_ready_queue(proc);</a>
<a name="ln333">  proc-&gt;state = PROC_BLOCKED;</a>
<a name="ln334"> </a>
<a name="ln335">  if (pid == scheduler-&gt;current_pid) {</a>
<a name="ln336">    yield();</a>
<a name="ln337">  }</a>
<a name="ln338"> </a>
<a name="ln339">  return 0;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">int unblock_process(int64_t pid) {</a>
<a name="ln343">  process_t *proc = get_process(pid);</a>
<a name="ln344"> </a>
<a name="ln345">  if (proc == NULL || proc-&gt;state != PROC_BLOCKED) {</a>
<a name="ln346">    return -1;</a>
<a name="ln347">  }</a>
<a name="ln348"> </a>
<a name="ln349">  proc-&gt;state = PROC_READY;</a>
<a name="ln350">  proc-&gt;remaining_quantum = quantum_for_priority(proc-&gt;priority);</a>
<a name="ln351"> </a>
<a name="ln352">  // VER!!: ver si tendriamos que verificar si la lista de readys no es null</a>
<a name="ln353">  enqueue_ready(proc);</a>
<a name="ln354"> </a>
<a name="ln355">  return 0;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">int block_current_process() {</a>
<a name="ln359">  int64_t pid = get_current_pid();</a>
<a name="ln360">  if (pid == NO_PID) {</a>
<a name="ln361">    return -1;</a>
<a name="ln362">  }</a>
<a name="ln363">  return block_process(pid);</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">int unblock_current_process() {</a>
<a name="ln367">  int64_t pid = get_current_pid();</a>
<a name="ln368">  if (pid == NO_PID) {</a>
<a name="ln369">    return -1;</a>
<a name="ln370">  }</a>
<a name="ln371">  return unblock_process(pid);</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">int set_process_priority(int64_t pid, uint8_t priority) {</a>
<a name="ln375">  if (scheduler == NULL || pid &lt; 0 || pid &gt;= MAX_PROCESSES ||</a>
<a name="ln376">      priority &lt; MIN_PRIORITY || priority &gt; MAX_PRIORITY) {</a>
<a name="ln377">    return -1;</a>
<a name="ln378">  }</a>
<a name="ln379"> </a>
<a name="ln380">  process_t *proc = scheduler-&gt;processes[pid];</a>
<a name="ln381"> </a>
<a name="ln382">  if (proc == NULL) {</a>
<a name="ln383">    return -1;</a>
<a name="ln384">  }</a>
<a name="ln385"> </a>
<a name="ln386">  uint8_t old_priority = proc-&gt;priority;</a>
<a name="ln387">  proc-&gt;priority = priority;</a>
<a name="ln388">  proc-&gt;remaining_quantum = quantum_for_priority(priority);</a>
<a name="ln389"> </a>
<a name="ln390">  if (proc-&gt;state == PROC_READY &amp;&amp; proc-&gt;in_ready_queue &amp;&amp;</a>
<a name="ln391">      old_priority != priority) {</a>
<a name="ln392">    remove_from_ready_queue(proc);</a>
<a name="ln393">    enqueue_ready(proc);</a>
<a name="ln394">  } else if (proc-&gt;state == PROC_RUNNING &amp;&amp; old_priority != priority) {</a>
<a name="ln395">    scheduler-&gt;force_reschedule = 1;</a>
<a name="ln396">  }</a>
<a name="ln397"> </a>
<a name="ln398">  return 0;</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">int64_t wait_pid(int64_t pid, int32_t *exit_code) {</a>
<a name="ln402"> </a>
<a name="ln403">  process_t *child = get_process(pid);</a>
<a name="ln404">  process_t *current = get_current_process();</a>
<a name="ln405"> </a>
<a name="ln406">  if (child == NULL || current == NULL) {</a>
<a name="ln407">    return -1;</a>
<a name="ln408">  }</a>
<a name="ln409"> </a>
<a name="ln410">  if (child-&gt;parent_pid != current-&gt;pid) {</a>
<a name="ln411">    return -1;</a>
<a name="ln412">  }</a>
<a name="ln413"> </a>
<a name="ln414">  if (child-&gt;state != PROC_KILLED) {</a>
<a name="ln415">  }</a>
<a name="ln416"> </a>
<a name="ln417">  if (child-&gt;state == PROC_KILLED) {</a>
<a name="ln418">    if (exit_code) {</a>
<a name="ln419">      *exit_code = child-&gt;return_value;</a>
<a name="ln420">    }</a>
<a name="ln421">    remove_process(pid);</a>
<a name="ln422">    current-&gt;waiting_pid = NO_PID;</a>
<a name="ln423">    return pid;</a>
<a name="ln424">  }</a>
<a name="ln425"> </a>
<a name="ln426">  current-&gt;waiting_pid = pid;</a>
<a name="ln427">  if (block_current_process() != 0) {</a>
<a name="ln428">    current-&gt;waiting_pid = NO_PID;</a>
<a name="ln429">    return -1;</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  child = get_process(pid);</a>
<a name="ln433">  if (child != NULL &amp;&amp; child-&gt;state == PROC_KILLED) {</a>
<a name="ln434">    if (exit_code) {</a>
<a name="ln435">      *exit_code = child-&gt;return_value;</a>
<a name="ln436">    }</a>
<a name="ln437">    remove_process(pid);</a>
<a name="ln438">    current-&gt;waiting_pid = NO_PID;</a>
<a name="ln439">    return pid;</a>
<a name="ln440">  }</a>
<a name="ln441"> </a>
<a name="ln442">  current-&gt;waiting_pid = NO_PID;</a>
<a name="ln443">  return -1;</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">void my_exit(int64_t ret) {</a>
<a name="ln447">  if (scheduler == NULL) {</a>
<a name="ln448">    return;</a>
<a name="ln449">  }</a>
<a name="ln450"> </a>
<a name="ln451">  process_t *current = get_current_process();</a>
<a name="ln452">  adopt_children(current-&gt;pid);</a>
<a name="ln453"> </a>
<a name="ln454">  if (scheduler-&gt;processes[scheduler-&gt;current_pid]-&gt;parent_pid == INIT_PID) {</a>
<a name="ln455">    remove_process(current-&gt;pid);</a>
<a name="ln456">  } else {</a>
<a name="ln457"> </a>
<a name="ln458">    if (current-&gt;in_ready_queue || current-&gt;state == PROC_RUNNING) {</a>
<a name="ln459">      remove_from_ready_queue(current);</a>
<a name="ln460">    }</a>
<a name="ln461"> </a>
<a name="ln462">    current-&gt;state = PROC_KILLED;</a>
<a name="ln463">    current-&gt;return_value = ret;</a>
<a name="ln464"> </a>
<a name="ln465">    process_t *parent = get_process(current-&gt;parent_pid);</a>
<a name="ln466"> </a>
<a name="ln467">    if (parent-&gt;state == PROC_BLOCKED &amp;&amp; parent-&gt;waiting_pid == current-&gt;pid) {</a>
<a name="ln468">      unblock_process(parent-&gt;pid);</a>
<a name="ln469">    }</a>
<a name="ln470">  }</a>
<a name="ln471"> </a>
<a name="ln472">  yield();</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">uint64_t total_ticks(void) {</a>
<a name="ln476">  if (scheduler == NULL) {</a>
<a name="ln477">    return 0;</a>
<a name="ln478">  }</a>
<a name="ln479">  return scheduler-&gt;total_cpu_ticks;</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">static uint8_t quantum_for_priority(uint8_t priority) {</a>
<a name="ln483">  if (priority &lt; MIN_PRIORITY) {</a>
<a name="ln484">    priority = MIN_PRIORITY;</a>
<a name="ln485">  } else if (priority &gt; MAX_PRIORITY) {</a>
<a name="ln486">    priority = MAX_PRIORITY;</a>
<a name="ln487">  }</a>
<a name="ln488">  return (priority - MIN_PRIORITY) + 1;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491">static void free_ready_queue(void) {</a>
<a name="ln492">  if (scheduler == NULL) {</a>
<a name="ln493">    return;</a>
<a name="ln494">  }</a>
<a name="ln495">  if (scheduler-&gt;ready_queue != NULL) {</a>
<a name="ln496">    free_list(scheduler-&gt;ready_queue);</a>
<a name="ln497">    scheduler-&gt;ready_queue = NULL;</a>
<a name="ln498">  }</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">static void enqueue_ready(process_t *proc) {</a>
<a name="ln502">  if (scheduler == NULL || scheduler-&gt;ready_queue == NULL || proc == NULL) {</a>
<a name="ln503">    return;</a>
<a name="ln504">  }</a>
<a name="ln505">  if (proc-&gt;in_ready_queue) {</a>
<a name="ln506">    return;</a>
<a name="ln507">  }</a>
<a name="ln508">  proc-&gt;state = PROC_READY;</a>
<a name="ln509">  if (add_last(scheduler-&gt;ready_queue, proc) == -1) {</a>
<a name="ln510">    proc-&gt;in_ready_queue = 0;</a>
<a name="ln511">  } else {</a>
<a name="ln512">    proc-&gt;in_ready_queue = 1;</a>
<a name="ln513">  }</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">static process_t *dequeue_ready(void) {</a>
<a name="ln517">  if (scheduler == NULL || scheduler-&gt;ready_queue == NULL) {</a>
<a name="ln518">    return NULL;</a>
<a name="ln519">  }</a>
<a name="ln520">  while (!is_empty(scheduler-&gt;ready_queue)) {</a>
<a name="ln521">    process_t *proc = get_first(scheduler-&gt;ready_queue);</a>
<a name="ln522">    delete_first(scheduler-&gt;ready_queue);</a>
<a name="ln523">    if (proc != NULL) {</a>
<a name="ln524">      proc-&gt;in_ready_queue = 0;</a>
<a name="ln525">      if (proc-&gt;state == PROC_READY) {</a>
<a name="ln526">        return proc;</a>
<a name="ln527">      }</a>
<a name="ln528">    }</a>
<a name="ln529">  }</a>
<a name="ln530">  return NULL;</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533">static void remove_from_ready_queue(process_t *proc) {</a>
<a name="ln534">  if (scheduler == NULL || scheduler-&gt;ready_queue == NULL || proc == NULL ||</a>
<a name="ln535">      !proc-&gt;in_ready_queue) {</a>
<a name="ln536">    return;</a>
<a name="ln537">  }</a>
<a name="ln538">  if (delete_element(scheduler-&gt;ready_queue, proc) == 0) {</a>
<a name="ln539">    proc-&gt;in_ready_queue = 0;</a>
<a name="ln540">    return;</a>
<a name="ln541">  }</a>
<a name="ln542">  proc-&gt;in_ready_queue = 0;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">uint8_t is_foreground_process(int64_t pid) {</a>
<a name="ln546">  if (scheduler == NULL || pid &lt; 0 || pid &gt;= MAX_PROCESSES ||</a>
<a name="ln547">      scheduler-&gt;processes[pid] == NULL) {</a>
<a name="ln548">    return 0;</a>
<a name="ln549">  }</a>
<a name="ln550">  return (scheduler-&gt;processes[SHELL_PID]-&gt;waiting_pid == pid);</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553">process_info_t *get_processes_info() {</a>
<a name="ln554">  static process_info_t processes_info[MAX_PROCESSES];</a>
<a name="ln555">  for (int k = 0; k &lt; MAX_PROCESSES; k++) {</a>
<a name="ln556">    processes_info[k].pid = NO_PID;</a>
<a name="ln557">    processes_info[k].name[0] = '\0';</a>
<a name="ln558">  }</a>
<a name="ln559"> </a>
<a name="ln560">  int j = 0;</a>
<a name="ln561">  for (int i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln562">    process_t *proc = scheduler-&gt;processes[i];</a>
<a name="ln563">    if (proc != NULL) {</a>
<a name="ln564">      process_info_t *proc_info = &amp;processes_info[j++];</a>
<a name="ln565">      my_strncpy(proc_info-&gt;name, proc-&gt;name, MAX_NAME_LEN);</a>
<a name="ln566">      proc_info-&gt;pid = proc-&gt;pid;</a>
<a name="ln567">      proc_info-&gt;parent_pid = proc-&gt;parent_pid;</a>
<a name="ln568">      proc_info-&gt;priority = proc-&gt;priority;</a>
<a name="ln569">      proc_info-&gt;stack_base = proc-&gt;stack_base;</a>
<a name="ln570">      proc_info-&gt;stack_pointer = proc-&gt;stack_pointer;</a>
<a name="ln571">      if (proc-&gt;stack_pointer != NULL) {</a>
<a name="ln572">        uint64_t *stack = (uint64_t *)proc-&gt;stack_pointer;</a>
<a name="ln573">        proc_info-&gt;rip = (void *)stack[STACK_RIP_OFFSET];</a>
<a name="ln574">      } else {</a>
<a name="ln575">        proc_info-&gt;rip = NULL;</a>
<a name="ln576">      }</a>
<a name="ln577">      proc_info-&gt;foreground = is_foreground_process(proc-&gt;pid);</a>
<a name="ln578">      proc_info-&gt;state = proc-&gt;state;</a>
<a name="ln579">      proc_info-&gt;ticks = proc-&gt;ticks;</a>
<a name="ln580">    }</a>
<a name="ln581">  }</a>
<a name="ln582">  processes_info[j].pid = NO_PID;</a>
<a name="ln583">  return processes_info;</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">void kill_foreground_process() {</a>
<a name="ln587">  if (scheduler == NULL) {</a>
<a name="ln588">    return;</a>
<a name="ln589">  }</a>
<a name="ln590"> </a>
<a name="ln591">  for (int i = 0; i &lt; MAX_PROCESSES; i++) {</a>
<a name="ln592">    process_t *proc = scheduler-&gt;processes[i];</a>
<a name="ln593"> </a>
<a name="ln594">    if (proc != NULL &amp;&amp; is_foreground_process(proc-&gt;pid)) {</a>
<a name="ln595">      if (proc-&gt;pid == SHELL_PID || proc-&gt;pid == INIT_PID) {</a>
<a name="ln596">        continue;</a>
<a name="ln597">      }</a>
<a name="ln598"> </a>
<a name="ln599">      printf(&quot;\n^C\n&quot;);</a>
<a name="ln600">      kill_process(proc-&gt;pid);</a>
<a name="ln601">      return;</a>
<a name="ln602">    }</a>
<a name="ln603">  }</a>
<a name="ln604">}</a>
</code></pre>
<div class="balloon" rel="483"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'priority &lt; 0' is always false. Unsigned type value is never &lt; 0.</p></div>
<div class="balloon" rel="31"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: ((void *) 0x400000) == 0.</p></div>
<div class="balloon" rel="292"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: proc-&gt;state == PROC_READY.</p></div>
<div class="balloon" rel="293"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: proc-&gt;state == PROC_RUNNING.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>