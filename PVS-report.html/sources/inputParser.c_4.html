<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>inputParser.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java:</a>
<a name="ln3">// https://pvs-studio.com</a>
<a name="ln4"></a>
<a name="ln5">#include &quot;inputParser.h&quot;</a>
<a name="ln6">#include &quot;stdlib.h&quot;</a>
<a name="ln7">#include &quot;string.h&quot;</a>
<a name="ln8">#include &lt;stddef.h&gt;</a>
<a name="ln9"></a>
<a name="ln10">#define PIPE_CHAR '|'</a>
<a name="ln11">#define BACKGROUND_CHAR '&amp;'</a>
<a name="ln12"></a>
<a name="ln13">static shell_program_t *extract_command_info(char **command_line);</a>
<a name="ln14">static void skip_whitespace(char **str);</a>
<a name="ln15">static void free_program_memory(shell_program_t *prog);</a>
<a name="ln16">static int allocate_argument(shell_program_t *cmd, int arg_index);</a>
<a name="ln17">static int tokenize_arguments(shell_program_t *cmd, char **line_ptr);</a>
<a name="ln18"></a>
<a name="ln19">input_parser_t *parse_input(char *command_line) {</a>
<a name="ln20">  input_parser_t *result = (input_parser_t *)my_malloc(sizeof(input_parser_t));</a>
<a name="ln21">  if (!result) {</a>
<a name="ln22">    return NULL;</a>
<a name="ln23">  }</a>
<a name="ln24"></a>
<a name="ln25">  result-&gt;shell_programs = (shell_program_t **)my_malloc(</a>
<a name="ln26">      sizeof(shell_program_t *) * MAX_CHAINED_PROGRAMS);</a>
<a name="ln27"></a>
<a name="ln28">  if (!result-&gt;shell_programs) {</a>
<a name="ln29">    my_free(result);</a>
<a name="ln30">    return NULL;</a>
<a name="ln31">  }</a>
<a name="ln32"></a>
<a name="ln33">  int i;</a>
<a name="ln34">  for (i = 0; i &lt; MAX_CHAINED_PROGRAMS; i++) {</a>
<a name="ln35">    result-&gt;shell_programs[i] = NULL;</a>
<a name="ln36">  }</a>
<a name="ln37">  result-&gt;qty_shell_programs = 1;</a>
<a name="ln38">  result-&gt;background = 0;</a>
<a name="ln39"></a>
<a name="ln40">  skip_whitespace(&amp;command_line);</a>
<a name="ln41"></a>
<a name="ln42">  if (*command_line == '\0' || *command_line == '\n') {</a>
<a name="ln43">    result-&gt;qty_shell_programs = 0;</a>
<a name="ln44">    return result;</a>
<a name="ln45">  }</a>
<a name="ln46"></a>
<a name="ln47">  shell_program_t *cmd_left = extract_command_info(&amp;command_line);</a>
<a name="ln48">  shell_program_t *cmd_right = NULL;</a>
<a name="ln49"></a>
<a name="ln50">  if (*command_line == PIPE_CHAR) {</a>
<a name="ln51">    command_line++;</a>
<a name="ln52">    skip_whitespace(&amp;command_line);</a>
<a name="ln53">    cmd_right = extract_command_info(&amp;command_line);</a>
<a name="ln54">    if (cmd_right) {</a>
<a name="ln55">      result-&gt;qty_shell_programs++;</a>
<a name="ln56">    }</a>
<a name="ln57">  }</a>
<a name="ln58"></a>
<a name="ln59">  if (*command_line == BACKGROUND_CHAR) {</a>
<a name="ln60">    result-&gt;background = 1;</a>
<a name="ln61">  }</a>
<a name="ln62"></a>
<a name="ln63">  result-&gt;shell_programs[0] = cmd_left;</a>
<a name="ln64">  result-&gt;shell_programs[1] = cmd_right;</a>
<a name="ln65"></a>
<a name="ln66">  return result;</a>
<a name="ln67">}</a>
<a name="ln68"></a>
<a name="ln69">static void skip_whitespace(char **str) {</a>
<a name="ln70">  while (**str == ' ') {</a>
<a name="ln71">    (*str)++;</a>
<a name="ln72">  }</a>
<a name="ln73">}</a>
<a name="ln74"></a>
<a name="ln75">static shell_program_t *extract_command_info(char **line_ptr) {</a>
<a name="ln76">  shell_program_t *cmd = (shell_program_t *)my_malloc(sizeof(shell_program_t));</a>
<a name="ln77">  if (!cmd) {</a>
<a name="ln78">    return NULL;</a>
<a name="ln79">  }</a>
<a name="ln80"></a>
<a name="ln81">  cmd-&gt;params = (char **)my_malloc(sizeof(char *) * (MAX_PARAM_LEN + 2));</a>
<a name="ln82">  if (!cmd-&gt;params) {</a>
<a name="ln83">    my_free(cmd);</a>
<a name="ln84">    return NULL;</a>
<a name="ln85">  }</a>
<a name="ln86"></a>
<a name="ln87">  int j;</a>
<a name="ln88">  for (j = 0; j &lt; (MAX_PARAM_LEN + 2); j++) {</a>
<a name="ln89">    cmd-&gt;params[j] = NULL;</a>
<a name="ln90">  }</a>
<a name="ln91"></a>
<a name="ln92">  cmd-&gt;name = (char *)my_malloc(MAX_PARAM_LEN);</a>
<a name="ln93">  if (!cmd-&gt;name) {</a>
<a name="ln94">    my_free(cmd-&gt;params);</a>
<a name="ln95">    my_free(cmd);</a>
<a name="ln96">    return NULL;</a>
<a name="ln97">  }</a>
<a name="ln98"></a>
<a name="ln99">  int bytes_copied = strcpychar_n(cmd-&gt;name, *line_ptr, ' ', MAX_COMMAND_LEN);</a>
<a name="ln100">  *line_ptr += bytes_copied;</a>
<a name="ln101">  skip_whitespace(line_ptr);</a>
<a name="ln102"></a>
<a name="ln103">  if (!allocate_argument(cmd, 0)) {</a>
<a name="ln104">    free_program_memory(cmd);</a>
<a name="ln105">    return NULL;</a>
<a name="ln106">  }</a>
<a name="ln107">  strcpy(cmd-&gt;params[0], cmd-&gt;name);</a>
<a name="ln108"></a>
<a name="ln109">  int total_args = tokenize_arguments(cmd, line_ptr);</a>
<a name="ln110">  if (total_args &lt; 0) {</a>
<a name="ln111">    free_program_memory(cmd);</a>
<a name="ln112">    return NULL;</a>
<a name="ln113">  }</a>
<a name="ln114"></a>
<a name="ln115">  return cmd;</a>
<a name="ln116">}</a>
<a name="ln117"></a>
<a name="ln118">static int allocate_argument(shell_program_t *cmd, int arg_index) {</a>
<a name="ln119">  cmd-&gt;params[arg_index] = my_malloc(MAX_PARAM_LEN);</a>
<a name="ln120">  return (cmd-&gt;params[arg_index] != NULL);</a>
<a name="ln121">}</a>
<a name="ln122"></a>
<a name="ln123">static int tokenize_arguments(shell_program_t *cmd, char **line_ptr) {</a>
<a name="ln124">  int arg_count = 1;</a>
<a name="ln125">  int bytes_read = 1;</a>
<a name="ln126"></a>
<a name="ln127">  while (bytes_read &gt; 0 &amp;&amp; **line_ptr != PIPE_CHAR &amp;&amp;</a>
<a name="ln128">         **line_ptr != BACKGROUND_CHAR &amp;&amp; **line_ptr != '\0' &amp;&amp;</a>
<a name="ln129">         **line_ptr != '\n') {</a>
<a name="ln130"></a>
<a name="ln131">    if (!allocate_argument(cmd, arg_count)) {</a>
<a name="ln132">      return -1;</a>
<a name="ln133">    }</a>
<a name="ln134"></a>
<a name="ln135">    bytes_read =</a>
<a name="ln136">        strcpychar_n(cmd-&gt;params[arg_count], *line_ptr, ' ', MAX_PARAM_LEN);</a>
<a name="ln137"></a>
<a name="ln138">    if (bytes_read &gt; 0) {</a>
<a name="ln139">      arg_count++;</a>
<a name="ln140">      *line_ptr += bytes_read;</a>
<a name="ln141">      skip_whitespace(line_ptr);</a>
<a name="ln142">    } else {</a>
<a name="ln143">      my_free(cmd-&gt;params[arg_count]);</a>
<a name="ln144">      cmd-&gt;params[arg_count] = NULL;</a>
<a name="ln145">    }</a>
<a name="ln146">  }</a>
<a name="ln147"></a>
<a name="ln148">  cmd-&gt;params[arg_count] = NULL;</a>
<a name="ln149">  return arg_count;</a>
<a name="ln150">}</a>
<a name="ln151"></a>
<a name="ln152">static void free_program_memory(shell_program_t *prog) {</a>
<a name="ln153">  if (!prog) {</a>
<a name="ln154">    return;</a>
<a name="ln155">  }</a>
<a name="ln156"></a>
<a name="ln157">  int i = 0;</a>
<a name="ln158">  while (prog-&gt;params &amp;&amp; prog-&gt;params[i] != NULL) {</a>
<a name="ln159">    my_free(prog-&gt;params[i]);</a>
<a name="ln160">    i++;</a>
<a name="ln161">  }</a>
<a name="ln162"></a>
<a name="ln163">  if (prog-&gt;params) {</a>
<a name="ln164">    my_free(prog-&gt;params);</a>
<a name="ln165">  }</a>
<a name="ln166">  if (prog-&gt;name) {</a>
<a name="ln167">    my_free(prog-&gt;name);</a>
<a name="ln168">  }</a>
<a name="ln169">  my_free(prog);</a>
<a name="ln170">}</a>
<a name="ln171"></a>
<a name="ln172">void free_parser(input_parser_t *parser) {</a>
<a name="ln173">  if (!parser) {</a>
<a name="ln174">    return;</a>
<a name="ln175">  }</a>
<a name="ln176"></a>
<a name="ln177">  int i;</a>
<a name="ln178">  for (i = 0; i &lt; MAX_CHAINED_PROGRAMS; i++) {</a>
<a name="ln179">    if (parser-&gt;shell_programs[i] != NULL) {</a>
<a name="ln180">      free_program_memory(parser-&gt;shell_programs[i]);</a>
<a name="ln181">    }</a>
<a name="ln182">  }</a>
<a name="ln183"></a>
<a name="ln184">  if (parser-&gt;shell_programs) {</a>
<a name="ln185">    my_free(parser-&gt;shell_programs);</a>
<a name="ln186">  }</a>
<a name="ln187">  my_free(parser);</a>
<a name="ln188">}</a>
</code></pre>
<div class="balloon" rel="180"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'parser-&gt;shell_programs' pointer was utilized before it was verified against nullptr. Check lines: 180, 184.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>